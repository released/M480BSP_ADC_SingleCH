; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.ADC_Convert_Ext_Channel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  ADC_Convert_Ext_Channel PROC
;;;117    */
;;;118    void ADC_Convert_Ext_Channel(uint8_t ch)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;119    {
;;;120    	uint8_t i = 0;
;;;121    	uint32_t ModuleMask = BIT0 ;		// use bit 0 as module ask
;;;122    	uint32_t ModuleNum = 0 ;		// use ch 0 as module num
;;;123    	
;;;124        /* Set input mode as single-end, and Single mode*/
;;;125        EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);
000004  4e51              LDR      r6,|L1.332|
000006  4681              MOV      r9,r0                 ;119
000008  2500              MOVS     r5,#0                 ;122
00000a  2401              MOVS     r4,#1                 ;121
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       EADC_Open
;;;126    
;;;127        EADC_SetExtendSampleTime(EADC, ch, 0x3F);
000014  223f              MOVS     r2,#0x3f
000016  4649              MOV      r1,r9
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       EADC_SetExtendSampleTime
;;;128    	
;;;129    	EADC_ConfigSampleModule(EADC, ModuleNum, EADC_ADINT0_TRIGGER, ch);
00001e  464b              MOV      r3,r9
000020  0462              LSLS     r2,r4,#17
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       EADC_ConfigSampleModule
;;;130    
;;;131        EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);
00002a  2001              MOVS     r0,#1
00002c  f8c600f8          STR      r0,[r6,#0xf8]
;;;132    	
;;;133        EADC_ENABLE_INT(EADC, BIT0);
000030  6d30              LDR      r0,[r6,#0x50]
000032  f0400004          ORR      r0,r0,#4
000036  6530              STR      r0,[r6,#0x50]
;;;134        EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 0, (ModuleMask));
000038  f8d600d0          LDR      r0,[r6,#0xd0]
00003c  f0400001          ORR      r0,r0,#1
000040  f8c600d0          STR      r0,[r6,#0xd0]
;;;135        NVIC_EnableIRQ(EADC00_IRQn);
000044  202a              MOVS     r0,#0x2a
000046  f7fffffe          BL       NVIC_EnableIRQ
;;;136    
;;;137    	switch(ch)
;;;138    	{
;;;139    		case ADC0_CH7: 
;;;140    
;;;141    			set_flag(flag_ADC_Data_Ready , DISABLE);				
00004a  4941              LDR      r1,|L1.336|
00004c  4648              MOV      r0,r9                 ;137
;;;142    			EADC_START_CONV(EADC, (ModuleMask));				
;;;143    //			while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);		
;;;144    			while(EADC_GET_DATA_VALID_FLAG(EADC, (ModuleMask)) != (ModuleMask));
;;;145    			
;;;146    			aADCxConvertedData[0] = EADC_GET_CONV_DATA(EADC, ModuleNum);
00004e  f1010714          ADD      r7,r1,#0x14
000052  f1b90f07          CMP      r9,#7                 ;137
000056  d007              BEQ      |L1.104|
000058  2808              CMP      r0,#8                 ;137
00005a  d019              BEQ      |L1.144|
00005c  2809              CMP      r0,#9                 ;137
00005e  d02b              BEQ      |L1.184|
000060  f1b90f0a          CMP      r9,#0xa               ;137
000064  d14f              BNE      |L1.262|
000066  e03b              B        |L1.224|
                  |L1.104|
000068  6908              LDR      r0,[r1,#0x10]         ;141  ; BitFlag
00006a  f0200001          BIC      r0,r0,#1              ;141
00006e  6108              STR      r0,[r1,#0x10]         ;141  ; BitFlag
000070  6574              STR      r4,[r6,#0x54]         ;142
                  |L1.114|
000072  f8d600f4          LDR      r0,[r6,#0xf4]         ;144
000076  f0000107          AND      r1,r0,#7              ;144
00007a  f8d600f0          LDR      r0,[r6,#0xf0]         ;144
00007e  f361401f          BFI      r0,r1,#16,#16         ;144
000082  ea340000          BICS     r0,r4,r0              ;144
000086  d1f4              BNE      |L1.114|
000088  f8560025          LDR      r0,[r6,r5,LSL #2]
00008c  8038              STRH     r0,[r7,#0]
;;;147    
;;;148    			break;
00008e  e03a              B        |L1.262|
                  |L1.144|
;;;149    
;;;150    		case ADC0_CH8: 
;;;151    
;;;152    			set_flag(flag_ADC_Data_Ready , DISABLE);				
000090  6908              LDR      r0,[r1,#0x10]  ; BitFlag
000092  f0200001          BIC      r0,r0,#1
000096  6108              STR      r0,[r1,#0x10]  ; BitFlag
;;;153    			EADC_START_CONV(EADC, (ModuleMask));						
000098  6574              STR      r4,[r6,#0x54]
                  |L1.154|
;;;154    //			while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);		
;;;155    			while(EADC_GET_DATA_VALID_FLAG(EADC, (ModuleMask)) != (ModuleMask));
00009a  f8d600f4          LDR      r0,[r6,#0xf4]
00009e  f0000107          AND      r1,r0,#7
0000a2  f8d600f0          LDR      r0,[r6,#0xf0]
0000a6  f361401f          BFI      r0,r1,#16,#16
0000aa  ea340000          BICS     r0,r4,r0
0000ae  d1f4              BNE      |L1.154|
;;;156    			
;;;157    			aADCxConvertedData[1] = EADC_GET_CONV_DATA(EADC, ModuleNum);
0000b0  f8560025          LDR      r0,[r6,r5,LSL #2]
0000b4  8078              STRH     r0,[r7,#2]
;;;158    
;;;159    			break;
0000b6  e026              B        |L1.262|
                  |L1.184|
;;;160    
;;;161    		case ADC0_CH9: 
;;;162    
;;;163    			set_flag(flag_ADC_Data_Ready , DISABLE);				
0000b8  6908              LDR      r0,[r1,#0x10]  ; BitFlag
0000ba  f0200001          BIC      r0,r0,#1
0000be  6108              STR      r0,[r1,#0x10]  ; BitFlag
;;;164    			EADC_START_CONV(EADC, (ModuleMask));						
0000c0  6574              STR      r4,[r6,#0x54]
                  |L1.194|
;;;165    //			while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);		
;;;166    			while(EADC_GET_DATA_VALID_FLAG(EADC, (ModuleMask)) != (ModuleMask));
0000c2  f8d600f4          LDR      r0,[r6,#0xf4]
0000c6  f0000107          AND      r1,r0,#7
0000ca  f8d600f0          LDR      r0,[r6,#0xf0]
0000ce  f361401f          BFI      r0,r1,#16,#16
0000d2  ea340000          BICS     r0,r4,r0
0000d6  d1f4              BNE      |L1.194|
;;;167    			
;;;168    			aADCxConvertedData[2] = EADC_GET_CONV_DATA(EADC, ModuleNum);
0000d8  f8560025          LDR      r0,[r6,r5,LSL #2]
0000dc  80b8              STRH     r0,[r7,#4]
;;;169    
;;;170    			break;
0000de  e012              B        |L1.262|
                  |L1.224|
;;;171    
;;;172    		case ADC0_CH10: 
;;;173    
;;;174    			set_flag(flag_ADC_Data_Ready , DISABLE);				
0000e0  6908              LDR      r0,[r1,#0x10]  ; BitFlag
0000e2  f0200001          BIC      r0,r0,#1
0000e6  6108              STR      r0,[r1,#0x10]  ; BitFlag
;;;175    			EADC_START_CONV(EADC, (ModuleMask));						
0000e8  6574              STR      r4,[r6,#0x54]
                  |L1.234|
;;;176    //			while(is_flag_set(flag_ADC_Data_Ready) == DISABLE);
;;;177    			while(EADC_GET_DATA_VALID_FLAG(EADC, (ModuleMask)) != (ModuleMask));
0000ea  f8d600f4          LDR      r0,[r6,#0xf4]
0000ee  f0000107          AND      r1,r0,#7
0000f2  f8d600f0          LDR      r0,[r6,#0xf0]
0000f6  f361401f          BFI      r0,r1,#16,#16
0000fa  ea340000          BICS     r0,r4,r0
0000fe  d1f4              BNE      |L1.234|
;;;178    			
;;;179    			aADCxConvertedData[3] = EADC_GET_CONV_DATA(EADC, ModuleNum);
000100  f8560025          LDR      r0,[r6,r5,LSL #2]
000104  80f8              STRH     r0,[r7,#6]
                  |L1.262|
;;;180    
;;;181    			break;		
;;;182    	}
;;;183    	
;;;184    	for (i = 0 ; i < 4; i++)
000106  2500              MOVS     r5,#0
;;;185    	{
;;;186    		printf("(CH:%2d)0x%3X,%4dmv" , ch , aADCxConvertedData[i] , ADC_CALC_DATA_TO_VOLTAGE(aADCxConvertedData[i],3300));
000108  f64078ff          MOV      r8,#0xfff
                  |L1.268|
00010c  f8372015          LDRH     r2,[r7,r5,LSL #1]
000110  f64040e4          MOV      r0,#0xce4
000114  4350              MULS     r0,r2,r0
000116  fbb0f3f8          UDIV     r3,r0,r8
00011a  4649              MOV      r1,r9
00011c  a00d              ADR      r0,|L1.340|
00011e  f7fffffe          BL       __2printf
000122  1c6d              ADDS     r5,r5,#1
000124  b2ed              UXTB     r5,r5                 ;184
000126  2d04              CMP      r5,#4                 ;184
000128  d3f0              BCC      |L1.268|
;;;187    	}
;;;188    //	printf(",0x%3X,0x%3X,0x%3X" , Vgap , Vtemp, Vbat);
;;;189       
;;;190    	printf("\r\n");
00012a  a00f              ADR      r0,|L1.360|
00012c  f7fffffe          BL       __2printf
;;;191    
;;;192        EADC_DISABLE_SAMPLE_MODULE_INT(EADC, 0, (ModuleMask));
000130  f8d600d0          LDR      r0,[r6,#0xd0]
000134  43a0              BICS     r0,r0,r4
000136  f8c600d0          STR      r0,[r6,#0xd0]
;;;193        EADC_DISABLE_INT(EADC, BIT0);
00013a  6d30              LDR      r0,[r6,#0x50]
00013c  f0200004          BIC      r0,r0,#4
000140  6530              STR      r0,[r6,#0x50]
;;;194     	NVIC_DisableIRQ(EADC00_IRQn);
000142  e8bd47f0          POP      {r4-r10,lr}
000146  202a              MOVS     r0,#0x2a
000148  f7ffbffe          B.W      NVIC_DisableIRQ
;;;195    	
;;;196    }
;;;197    
                          ENDP

                  |L1.332|
                          DCD      0x40043000
                  |L1.336|
                          DCD      ||.data||
                  |L1.340|
000154  2843483a          DCB      "(CH:%2d)0x%3X,%4dmv",0
000158  25326429
00015c  30782533
000160  582c2534
000164  646d7600
                  |L1.360|
000168  0d0a00            DCB      "\r\n",0
00016b  00                DCB      0

                          AREA ||i.ADC_Read_Int_Channel||, CODE, READONLY, ALIGN=2

                  ADC_Read_Int_Channel PROC
;;;80     
;;;81     void ADC_Read_Int_Channel(void)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	
;;;84        /* Set input mode as single-end and enable the A/D converter */
;;;85         EADC_Open(EADC, EADC_CTL_DIFFEN_SINGLE_END);
000002  4c25              LDR      r4,|L2.152|
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       EADC_Open
;;;86     
;;;87         /* Set sample module 16 external sampling time to 0xF */
;;;88         EADC_SetExtendSampleTime(EADC, ADC0_CH16_BAND_GAP_VOLT, 0x3F);
00000c  223f              MOVS     r2,#0x3f
00000e  2110              MOVS     r1,#0x10
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       EADC_SetExtendSampleTime
;;;89         EADC_SetExtendSampleTime(EADC, ADC0_CH17_TEMP_SENSOR, 0x3F);
000016  223f              MOVS     r2,#0x3f
000018  2111              MOVS     r1,#0x11
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       EADC_SetExtendSampleTime
;;;90     
;;;91         EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF2_Msk);
000020  2004              MOVS     r0,#4
000022  f8c400f8          STR      r0,[r4,#0xf8]
;;;92         EADC_ENABLE_INT(EADC, (BIT0 << 2));
000026  f8540f50          LDR      r0,[r4,#0x50]!
00002a  f0400010          ORR      r0,r0,#0x10
00002e  f8440b2c          STR      r0,[r4],#0x2c
;;;93         EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 2, (BIT0 << ADC0_CH16_BAND_GAP_VOLT));
000032  6de0              LDR      r0,[r4,#0x5c]
000034  f4403080          ORR      r0,r0,#0x10000
000038  65e0              STR      r0,[r4,#0x5c]
;;;94         EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 2, (BIT0 << ADC0_CH17_TEMP_SENSOR));
00003a  6de0              LDR      r0,[r4,#0x5c]
00003c  f4403000          ORR      r0,r0,#0x20000
000040  65e0              STR      r0,[r4,#0x5c]
;;;95         EADC_ENABLE_SAMPLE_MODULE_INT(EADC, 2, (BIT0 << ADC0_CH18_VBAT));
000042  6de0              LDR      r0,[r4,#0x5c]
000044  f4402080          ORR      r0,r0,#0x40000
000048  65e0              STR      r0,[r4,#0x5c]
;;;96     	
;;;97         NVIC_EnableIRQ(EADC02_IRQn);
00004a  202e              MOVS     r0,#0x2e
00004c  f7fffffe          BL       NVIC_EnableIRQ
;;;98     
;;;99         EADC_START_CONV(EADC, (BIT0 << ADC0_CH16_BAND_GAP_VOLT) | (BIT0 << ADC0_CH17_TEMP_SENSOR)| (BIT0 << ADC0_CH18_VBAT));
000050  f44f20e0          MOV      r0,#0x70000
000054  f8440c28          STR      r0,[r4,#-0x28]
;;;100    
;;;101        while(EADC_GET_DATA_VALID_FLAG(EADC, (BIT16|BIT17|BIT18)) != (BIT16|BIT17|BIT18));
000058  2007              MOVS     r0,#7
00005a  3c7c              SUBS     r4,r4,#0x7c
                  |L2.92|
00005c  f8d410f4          LDR      r1,[r4,#0xf4]
000060  f0010207          AND      r2,r1,#7
000064  f8d410f0          LDR      r1,[r4,#0xf0]
000068  f362411f          BFI      r1,r2,#16,#16
00006c  ebb04f11          CMP      r0,r1,LSR #16
000070  d1f4              BNE      |L2.92|
;;;102    
;;;103        Vgap = EADC_GET_CONV_DATA(EADC, ADC0_CH16_BAND_GAP_VOLT);
000072  6c20              LDR      r0,[r4,#0x40]
000074  b281              UXTH     r1,r0
000076  4809              LDR      r0,|L2.156|
;;;104        Vtemp = EADC_GET_CONV_DATA(EADC, ADC0_CH17_TEMP_SENSOR);
000078  6041              STR      r1,[r0,#4]  ; Vgap
00007a  6c61              LDR      r1,[r4,#0x44]
00007c  b289              UXTH     r1,r1
;;;105        Vbat = EADC_GET_CONV_DATA(EADC, ADC0_CH18_VBAT);
00007e  6081              STR      r1,[r0,#8]  ; Vtemp
000080  6ca1              LDR      r1,[r4,#0x48]
000082  b289              UXTH     r1,r1
;;;106    	
;;;107        EADC_DISABLE_INT(EADC, (BIT0 << 2));
000084  60c1              STR      r1,[r0,#0xc]  ; Vbat
000086  6d20              LDR      r0,[r4,#0x50]
000088  f0200010          BIC      r0,r0,#0x10
00008c  6520              STR      r0,[r4,#0x50]
;;;108     	NVIC_DisableIRQ(EADC02_IRQn);
00008e  e8bd4010          POP      {r4,lr}
000092  202e              MOVS     r0,#0x2e
000094  f7ffbffe          B.W      NVIC_DisableIRQ
;;;109    	
;;;110    }
;;;111    
                          ENDP

                  |L2.152|
                          DCD      0x40043000
                  |L2.156|
                          DCD      ||.data||

                          AREA ||i.EADC00_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC00_IRQHandler PROC
;;;69     
;;;70     void EADC00_IRQHandler(void)
000000  4804              LDR      r0,|L3.20|
;;;71     {
;;;72         set_flag(flag_ADC_Data_Ready , ENABLE);
000002  6901              LDR      r1,[r0,#0x10]  ; BitFlag
000004  f0410101          ORR      r1,r1,#1
000008  6101              STR      r1,[r0,#0x10]  ; BitFlag
;;;73         EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF0_Msk);      /* Clear the A/D ADINT0 interrupt flag */
00000a  4903              LDR      r1,|L3.24|
00000c  2001              MOVS     r0,#1
00000e  f8c100f8          STR      r0,[r1,#0xf8]
;;;74     }
000012  4770              BX       lr
;;;75     
                          ENDP

                  |L3.20|
                          DCD      ||.data||
                  |L3.24|
                          DCD      0x40043000

                          AREA ||i.EADC02_IRQHandler||, CODE, READONLY, ALIGN=2

                  EADC02_IRQHandler PROC
;;;75     
;;;76     void EADC02_IRQHandler(void)
000000  4902              LDR      r1,|L4.12|
;;;77     {
;;;78         EADC_CLR_INT_FLAG(EADC, EADC_STATUS2_ADIF2_Msk);
000002  2004              MOVS     r0,#4
000004  f8c100f8          STR      r0,[r1,#0xf8]
;;;79     }
000008  4770              BX       lr
;;;80     
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x40043000

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;235    
;;;236    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;237    {
;;;238    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L5.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;239    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;240    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;241    	
;;;242    }
;;;243    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_DisableIRQ PROC
;;;1636    */
;;;1637   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1638   {
;;;1639     NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01180          STR      r1,[r0,#0x180]
;;;1640   }
000014  4770              BX       lr
;;;1641   
                          ENDP


                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;243    
;;;244    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L8.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L8.10|
;;;245    {
;;;246        /*---------------------------------------------------------------------------------------------------------*/
;;;247        /* Init System Clock                                                                                       */
;;;248        /*---------------------------------------------------------------------------------------------------------*/
;;;249        /* Unlock protected registers */
;;;250        SYS_UnlockReg();
;;;251    
;;;252        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;253        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2540          MOV      r5,#0x40004000
000022  f8d50140          LDR      r0,[r5,#0x140]
000026  f02000f0          BIC      r0,r0,#0xf0
00002a  f8c50140          STR      r0,[r5,#0x140]
;;;254    
;;;255        /* Enable External XTAL (4~24 MHz) */
;;;256        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;257    
;;;258        /* Waiting for 12MHz clock ready */
;;;259        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;260    
;;;261        /* Set core clock as PLL_CLOCK from PLL */
;;;262        CLK_SetCoreClock(FREQ_192MHZ);
00003a  482d              LDR      r0,|L8.240|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;263        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;264        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;265    
;;;266        /* Enable UART clock */
;;;267        CLK_EnableModuleClock(UART0_MODULE);
000046  4e2b              LDR      r6,|L8.244|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;268    
;;;269        /* Select UART clock source from HXT */
;;;270        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       CLK_SetModuleClock
;;;271    
;;;272        /* Enable EADC module clock */
;;;273        CLK_EnableModuleClock(EADC_MODULE);
000058  4e27              LDR      r6,|L8.248|
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       CLK_EnableModuleClock
;;;274    
;;;275        /* EADC clock source is 96MHz, set divider to 8, EADC clock is 96/8 MHz */
;;;276        CLK_SetModuleClock(EADC_MODULE, 0, CLK_CLKDIV0_EADC(8));
000060  f44f22e0          MOV      r2,#0x70000
000064  2100              MOVS     r1,#0
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       CLK_SetModuleClock
;;;277    
;;;278    //    CLK_EnableModuleClock(PDMA_MODULE);
;;;279    
;;;280        CLK_EnableModuleClock(TMR1_MODULE);
00006c  4e23              LDR      r6,|L8.252|
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       CLK_EnableModuleClock
;;;281        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
000074  2200              MOVS     r2,#0
000076  f44f41e0          MOV      r1,#0x7000
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       CLK_SetModuleClock
;;;282    
;;;283    	CLK_EnableModuleClock(TMR0_MODULE);
000080  4e1f              LDR      r6,|L8.256|
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       CLK_EnableModuleClock
;;;284    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
000088  2200              MOVS     r2,#0
00008a  1569              ASRS     r1,r5,#21
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       CLK_SetModuleClock
;;;285    
;;;286        /* Update System Core Clock */
;;;287        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;288        SystemCoreClockUpdate();
000092  f7fffffe          BL       SystemCoreClockUpdate
;;;289    
;;;290        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;291        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000096  6be0              LDR      r0,[r4,#0x3c]
000098  f420007f          BIC      r0,r0,#0xff0000
00009c  63e0              STR      r0,[r4,#0x3c]
;;;292        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00009e  6be0              LDR      r0,[r4,#0x3c]
0000a0  f44000cc          ORR      r0,r0,#0x660000
0000a4  63e0              STR      r0,[r4,#0x3c]
;;;293    
;;;294        PB->MODE &= ~(GPIO_MODE_MODE7_Msk | GPIO_MODE_MODE8_Msk | GPIO_MODE_MODE9_Msk | GPIO_MODE_MODE10_Msk);
0000a6  6c28              LDR      r0,[r5,#0x40]
0000a8  f420107f          BIC      r0,r0,#0x3fc000
0000ac  6428              STR      r0,[r5,#0x40]
;;;295    
;;;296        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB7MFP_Msk );
0000ae  6ba0              LDR      r0,[r4,#0x38]
0000b0  f0204070          BIC      r0,r0,#0xf0000000
0000b4  63a0              STR      r0,[r4,#0x38]
;;;297        SYS->GPB_MFPL |= (SYS_GPB_MFPL_PB7MFP_EADC0_CH7);
0000b6  6ba0              LDR      r0,[r4,#0x38]
0000b8  f0405080          ORR      r0,r0,#0x10000000
0000bc  63a0              STR      r0,[r4,#0x38]
;;;298    
;;;299        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB8MFP_Msk | SYS_GPB_MFPH_PB9MFP_Msk | SYS_GPB_MFPH_PB10MFP_Msk);
0000be  6be0              LDR      r0,[r4,#0x3c]
0000c0  f36f000b          BFC      r0,#0,#12
0000c4  63e0              STR      r0,[r4,#0x3c]
;;;300        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB8MFP_EADC0_CH8 | SYS_GPB_MFPH_PB9MFP_EADC0_CH9 | SYS_GPB_MFPH_PB10MFP_EADC0_CH10);
0000c6  6be0              LDR      r0,[r4,#0x3c]
0000c8  f2401111          MOV      r1,#0x111
0000cc  4308              ORRS     r0,r0,r1
0000ce  63e0              STR      r0,[r4,#0x3c]
;;;301    
;;;302        /* Disable the GPB0 - GPB3 digital input path to avoid the leakage current. */
;;;303        GPIO_DISABLE_DIGITAL_PATH(PB, BIT10|BIT9|BIT8|BIT7);
0000d0  6c68              LDR      r0,[r5,#0x44]
0000d2  f04060f0          ORR      r0,r0,#0x7800000
0000d6  6468              STR      r0,[r5,#0x44]
;;;304    
;;;305        /* Enable temperature sensor */
;;;306        SYS->IVSCTL |= SYS_IVSCTL_VTEMPEN_Msk;
0000d8  69e0              LDR      r0,[r4,#0x1c]
0000da  f0400001          ORR      r0,r0,#1
0000de  61e0              STR      r0,[r4,#0x1c]
;;;307    
;;;308        /* Set reference voltage to external pin (3.3V) */
;;;309        SYS_SetVRef(SYS_VREFCTL_VREF_PIN);
0000e0  2000              MOVS     r0,#0
0000e2  f7fffffe          BL       SYS_SetVRef
0000e6  2000              MOVS     r0,#0
0000e8  f8c40100          STR      r0,[r4,#0x100]
;;;310    	
;;;311        /* Lock protected registers */
;;;312        SYS_LockReg();
;;;313    }
0000ec  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L8.240|
                          DCD      0x0b71b000
                  |L8.244|
                          DCD      0x57803d10
                  |L8.248|
                          DCD      0x4003fe1c
                  |L8.252|
                          DCD      0x5ec00003
                  |L8.256|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;230    
;;;231    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;232    {
;;;233    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L9.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;234    }
;;;235    
                          ENDP

                  |L9.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;221    
;;;222    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L10.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;225        TIMER_EnableInt(TIMER1);
;;;226        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;227        TIMER_Start(TIMER1);
;;;228    }
000028  bd10              POP      {r4,pc}
;;;229    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;198    
;;;199    void TMR1_IRQHandler(void)
000000  480d              LDR      r0,|L11.56|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;200    {
000008  2900              CMP      r1,#0
00000a  d013              BEQ      |L11.52|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;201    	static uint16_t CNT = 0;	
;;;202    //	static uint32_t log = 0;	
;;;203    	
;;;204        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;205        {
;;;206            TIMER_ClearIntFlag(TIMER1);
;;;207    	
;;;208    		if (CNT++ > 1000)
000010  490a              LDR      r1,|L11.60|
000012  8808              LDRH     r0,[r1,#0]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  800a              STRH     r2,[r1,#0]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d90a              BLS      |L11.52|
;;;209    		{		
;;;210    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;211    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;212    //			ADC_Convert_Ext_Channel(ADC0_CH7);
;;;213    
;;;214    			set_flag(flag_ADC_Channel_Change , ENABLE);
000022  6908              LDR      r0,[r1,#0x10]  ; BitFlag
000024  f0400002          ORR      r0,r0,#2
000028  6108              STR      r0,[r1,#0x10]  ; BitFlag
;;;215    
;;;216    			LED_R ^= 1;
00002a  4805              LDR      r0,|L11.64|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0810101          EOR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L11.52|
;;;217    		}
;;;218        }
;;;219    }
000034  4770              BX       lr
;;;220    
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      0x40050100
                  |L11.60|
                          DCD      ||.data||
                  |L11.64|
                          DCD      0x400049c0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;322    
;;;323    int main()
000000  2407              MOVS     r4,#7
;;;324    {
;;;325    	uint8_t state = ADC0_CH7;
;;;326    	
;;;327        SYS_Init();
000002  f7fffffe          BL       SYS_Init
;;;328        /* Init UART to 115200-8n1 for print message */
;;;329        UART_Open(UART0, 115200);
000006  f44f31e1          MOV      r1,#0x1c200
00000a  481e              LDR      r0,|L12.132|
00000c  f7fffffe          BL       UART_Open
;;;330    
;;;331    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000010  f7fffffe          BL       CLK_GetCPUFreq
000014  4601              MOV      r1,r0
000016  a01c              ADR      r0,|L12.136|
000018  f7fffffe          BL       __2printf
;;;332    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001c  f7fffffe          BL       CLK_GetHXTFreq
000020  4601              MOV      r1,r0
000022  a020              ADR      r0,|L12.164|
000024  f7fffffe          BL       __2printf
;;;333    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000028  f7fffffe          BL       CLK_GetLXTFreq
00002c  4601              MOV      r1,r0
00002e  a023              ADR      r0,|L12.188|
000030  f7fffffe          BL       __2printf
;;;334    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000034  f7fffffe          BL       CLK_GetPCLK0Freq
000038  4601              MOV      r1,r0
00003a  a026              ADR      r0,|L12.212|
00003c  f7fffffe          BL       __2printf
;;;335    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000040  f7fffffe          BL       CLK_GetPCLK1Freq
000044  4601              MOV      r1,r0
000046  a02a              ADR      r0,|L12.240|
000048  f7fffffe          BL       __2printf
;;;336    
;;;337    
;;;338    	LED_Init();
00004c  f7fffffe          BL       LED_Init
;;;339    	TIMER1_Init();
000050  f7fffffe          BL       TIMER1_Init
;;;340    //	ADC_Read_Int_Channel();
;;;341    
;;;342        /* Got no where to go, just loop forever */
;;;343        while(1)
;;;344        {
;;;345    //		TIMER0_Polling(1000);
;;;346    		LED_Y ^= 1;
000054  4e2d              LDR      r6,|L12.268|
;;;347    
;;;348    		ADC_Convert_Ext_Channel(state);
;;;349    		
;;;350    		if (is_flag_set(flag_ADC_Channel_Change))
000056  4d2e              LDR      r5,|L12.272|
                  |L12.88|
000058  6830              LDR      r0,[r6,#0]            ;346
00005a  f0800001          EOR      r0,r0,#1              ;346
00005e  6030              STR      r0,[r6,#0]            ;346
000060  4620              MOV      r0,r4                 ;348
000062  f7fffffe          BL       ADC_Convert_Ext_Channel
000066  6928              LDR      r0,[r5,#0x10]  ; BitFlag
000068  0780              LSLS     r0,r0,#30
00006a  d5f5              BPL      |L12.88|
;;;351    		{
;;;352    			set_flag(flag_ADC_Channel_Change ,DISABLE);					
00006c  6928              LDR      r0,[r5,#0x10]  ; BitFlag
00006e  f0200002          BIC      r0,r0,#2
000072  6128              STR      r0,[r5,#0x10]  ; BitFlag
;;;353    			state = (state >= ADC0_CH10) ? (ADC0_CH7) : (state+1) ;
000074  2c0a              CMP      r4,#0xa
000076  d301              BCC      |L12.124|
000078  2407              MOVS     r4,#7
00007a  e000              B        |L12.126|
                  |L12.124|
00007c  1c64              ADDS     r4,r4,#1
                  |L12.126|
00007e  b2e4              UXTB     r4,r4
000080  e7ea              B        |L12.88|
;;;354    		}	
;;;355        }
;;;356    
;;;357    }
;;;358    
                          ENDP

000082  0000              DCW      0x0000
                  |L12.132|
                          DCD      0x40070000
                  |L12.136|
000088  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00008c  4b5f4765
000090  74435055
000094  46726571
000098  203a2025
00009c  38640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L12.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L12.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L12.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b30
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L12.240|
0000f0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f4  47657450
0000f8  434c4b31
0000fc  46726571
000100  203a2025
000104  38640d0a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L12.268|
                          DCD      0x400049c4
                  |L12.272|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  ||CNT||
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  Vgap
                          DCD      0x00000000
                  Vtemp
                          DCD      0x00000000
                  Vbat
                          DCD      0x00000000
                  BitFlag
                          DCD      0x00000000
                  aADCxConvertedData
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00
                          DCD      0x00000000

                          AREA ||area_number.16||, DATA, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.data||
                  ADC_CH_TypeDef
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_164135a7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____REVSH|
#line 402
|__asm___6_main_c_164135a7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_164135a7____RRX|
#line 587
|__asm___6_main_c_164135a7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
